<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Head Office Air Picture (for show)</title>

  <!-- Leaflet -->
  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
    integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
    crossorigin=""
  />
  <script
    src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
    integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
    crossorigin=""
  ></script>

  <style>
    :root{
      --bg: #050608;
      --panel: rgba(10,12,16,0.88);
      --panel2: rgba(10,12,16,0.74);
      --text: #e7eefc;
      --muted: rgba(231,238,252,0.70);
      --border: rgba(255,255,255,0.12);

      --green: #39ff14;
      --red:   #ff2b2b;
      --yellow:#ffe600;
      --cyan:  #2dd8ff;
    }

    html, body {
      height: 100%;
      margin: 0;
      background: var(--bg);
      color: var(--text);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
      overflow: hidden;
    }

    #map { position:absolute; inset:0; background:#000; }

    /* IMPORTANT: dim only the base tiles, not overlays */
 /* Map brightness controlled via CSS variable */
.leaflet-tile-pane{
  filter: brightness(var(--tile-brightness, 0.75)) contrast(1.10) saturate(1.05);
}

    /* Keep overlays crisp and bright */
    .leaflet-overlay-pane,
    .leaflet-marker-pane {
      filter: none !important;
    }

    /* Radar sweep canvas sits ABOVE map and ABOVE markers */
    .radar-overlay{
      pointer-events:none;
      position:absolute;
      inset:0;
      z-index:2000;
      opacity: 0.95;
    }

    /* Title bar */
    .titlebar{
      position:absolute;
      left:50%;
      top:10px;
      transform:translateX(-50%);
      z-index:2100;
      padding:10px 14px;
      background: rgba(10,12,16,0.82);
      border:1px solid var(--border);
      border-radius:10px;
      backdrop-filter: blur(8px);
      font-weight: 800;
      box-shadow: 0 12px 28px rgba(0,0,0,0.35);
      white-space: nowrap;
    }

    /* Right panel */
    .panel{
      position:absolute;
      right:14px;
      top:14px;
      z-index:2100;
      width:360px;
      max-width: calc(100vw - 28px);
      background: var(--panel);
      border:1px solid var(--border);
      border-radius:14px;
      padding:12px;
      backdrop-filter: blur(10px);
      box-shadow: 0 18px 44px rgba(0,0,0,0.45);
    }
    .panel h2{ margin:0 0 8px 0; font-size:14px; font-weight:900; }
    .kv{ font-size:12px; color:var(--muted); line-height:1.5; }

    .grid{
      display:grid;
      grid-template-columns:1fr 1fr;
      gap:10px;
      margin-top:10px;
    }
    .field{
      background: var(--panel2);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding:10px;
    }
    .field label{ display:block; font-size:12px; color:var(--muted); margin-bottom:6px; }
    .field input[type="number"]{
      width:100%;
      box-sizing:border-box;
      padding:8px 10px;
      border-radius:10px;
      border:1px solid rgba(255,255,255,0.14);
      background: rgba(0,0,0,0.35);
      color: var(--text);
      outline:none;
      font-size:13px;
    }

    .row{
      display:flex;
      gap:10px;
      align-items:center;
      margin-top:10px;
      flex-wrap:wrap;
    }
    .btn{
      cursor:pointer;
      user-select:none;
      padding:9px 10px;
      border-radius:10px;
      border:1px solid rgba(255,255,255,0.14);
      background: rgba(255,255,255,0.06);
      color: var(--text);
      font-weight: 800;
      font-size: 12px;
    }
    .btn:hover{ background: rgba(255,255,255,0.10); }

    .toggle{
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding:9px 10px;
      border-radius:10px;
      border:1px solid rgba(255,255,255,0.14);
      background: rgba(255,255,255,0.06);
      font-size:12px;
      font-weight:800;
    }
    .toggle input{ transform: translateY(1px); }

    .status{
      margin-top:10px;
      font-size:12px;
      color: var(--muted);
      display:flex;
      justify-content:space-between;
      gap:10px;
    }
    .pill{
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding:6px 10px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,0.14);
      background: rgba(0,0,0,0.35);
      font-size:12px;
      font-weight:900;
      color: var(--text);
    }

    /* ===== Aircraft marker (dot + label box) ===== */
    .ac-marker{
      display:flex;
      align-items:flex-start;
      gap:8px;
      transform: translate(-10px, -10px);
      pointer-events: none; /* keeps map interactions smooth */
    }
    .ac-dot{
      width:12px;
      height:12px;
      border-radius:999px;
      box-shadow:
        0 0 18px rgba(0,0,0,0.55),
        0 0 18px currentColor;
      border: 2px solid rgba(255,255,255,0.25);
      background: currentColor;
      flex: 0 0 auto;
      margin-top: 2px;
    }
    .ac-label{
      min-width: 150px;
      max-width: 240px;
      padding: 6px 8px;
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,0.14);
      background: rgba(0,0,0,0.72);
      color: rgba(231,238,252,0.92);
      box-shadow: 0 10px 24px rgba(0,0,0,0.45);
      backdrop-filter: blur(6px);
      line-height: 1.25;
      font-size: 12px;
      font-weight: 700;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .ac-label .top{ font-weight: 900; color: #fff; }
    .ac-label .sub{ opacity: 0.85; font-weight: 700; font-size: 11px; }

    /* Optional: tighter labels on smaller screens */
    @media (max-width: 900px){
      .panel{ width: 320px; }
      .ac-label{ min-width: 120px; max-width: 200px; }
    }

    .leaflet-control-attribution{ display:none; }
  </style>
</head>

<body class="dark-tiles">
  <div id="map"></div>
  <canvas class="radar-overlay" id="radarCanvas"></canvas>

<div class="titlebar" id="titlebar">Secur-IT ADS-B Tracking</div>

  <div class="panel">
    <h2>Controls</h2>
    <div class="kv">
      Centre: <span id="centreText"></span><br/>
      Filters: under <span id="ceilingText"></span> ft, within <span id="searchText"></span> km, warn within <span id="warnText"></span> km<br/>
      Polling: <span id="pollText"></span> (auto-pauses outside <span id="windowText"></span>)
    </div>

    <div class="grid">
      <div class="field">
        <label for="ceilingFt">Max altitude (ft)</label>
        <input id="ceilingFt" type="number" min="50" max="50000" step="50" value="1000" />
      </div>
      <div class="field">
        <label for="searchKm">Search radius (km)</label>
        <input id="searchKm" type="number" min="1" max="250" step="1" value="10" />
      </div>
      <div class="field">
        <label for="warnKm">Warning radius (km)</label>
        <input id="warnKm" type="number" min="1" max="250" step="1" value="5" />
      </div>
      <div class="field">
        <label for="staleSec">Max stale (sec)</label>
        <input id="staleSec" type="number" min="1" max="120" step="1" value="30" />
      </div>
      <div class="field">
        <label for="pollSec">Poll interval (sec)</label>
        <input id="pollSec" type="number" min="2" max="60" step="1" value="10" />
      </div>
      <div class="field">
        <label for="sweepSec">Radar sweep (sec)</label>
        <input id="sweepSec" type="number" min="2" max="20" step="1" value="6" />
      </div>
      <div class="field">
  <label for="tileBrightness">Map brightness</label>
  <input id="tileBrightness" type="range" min="0.2" max="1.4" step="0.05" value="0.75" />
</div>

    </div>

    <div class="row">
      <span class="toggle"><input type="checkbox" id="useMyLocation" /> Use my location</span>
      <span class="toggle"><input type="checkbox" id="nightMode" checked /> Dark tiles</span>
      <span class="toggle"><input type="checkbox" id="radarSweep" checked /> Radar sweep</span>
      <span class="toggle"><input type="checkbox" id="showVectors" checked /> Heading lines</span>
      <span class="toggle"><input type="checkbox" id="trails" checked /> Trails</span>
      <span class="toggle"><input type="checkbox" id="labelsOn" checked /> Label boxes</span>
    </div>

    <div class="row">
      <button class="btn" id="applyBtn">Apply</button>
      <button class="btn" id="recenterBtn">Re-centre</button>
      <button class="btn" id="reloadBtn">Hard reload</button>
      <span class="pill" id="visiblePill">Visible: 0</span>
    </div>

    <div class="status">
      <div>Last update: <span id="lastUpdate">–</span></div>
      <div>Status: <span id="statusText">Idle</span></div>
    </div>

    <div class="kv" style="margin-top:10px;">
      Colouring:<br/>
      <span style="color:var(--green);font-weight:900;">Green</span> outside warning,
      <span style="color:var(--yellow);font-weight:900;">Yellow</span> approaching warning,
      <span style="color:var(--red);font-weight:900;">Red</span> inside warning.
    </div>
  </div>

<script>
/* ============================
   CONFIG YOU WILL EDIT
   ============================ */
const WORKER_BASE = "https://raspy-breeze-3e34.j-wilkinson.workers.dev";
const HQ = { lat: 53.10643205468523, lon: -1.3190169903418059 };
const ACTIVE_WINDOW = { start: "08:30", end: "17:30" };
const HARD_RELOAD_MINUTES = 30;

/* ============================
   INTERNAL STATE
   ============================ */
let centre = { ...HQ };
let map, aircraftLayer;

let searchCircle, warnCircle;
let pollingTimer = null;
let hardReloadTimer = null;

const markerByHex = new Map(); // hex -> { marker, vectorLine, trailLine, trailPts }
let cfg = {
  ceilingFt: 1000,
  searchKm: 10,
  warnKm: 5,
  staleSec: 30,
  pollSec: 10,
  sweepSec: 6,
  useMyLocation: false,
  nightMode: true,
  radarSweep: true,
  showVectors: true,
  trails: true,
  labelsOn: true,
};

function $(id){ return document.getElementById(id); }
function clamp(n,a,b){ return Math.min(b, Math.max(a, n)); }
function isNumber(x){ return typeof x === "number" && Number.isFinite(x); }
function nowIsoTime(){
  return new Date().toLocaleTimeString([], { hour:"2-digit", minute:"2-digit", second:"2-digit" });
}
function kmToNm(km){ return km / 1.852; }

function parseHM(hm){
  const [h,m] = hm.split(":").map(x=>parseInt(x,10));
  return { h, m };
}
function isWithinWindow(d=new Date()){
  const s = parseHM(ACTIVE_WINDOW.start);
  const e = parseHM(ACTIVE_WINDOW.end);
  const mins = d.getHours()*60 + d.getMinutes();
  const sMins = s.h*60 + s.m;
  const eMins = e.h*60 + e.m;
  return mins >= sMins && mins <= eMins;
}

/* ============================
   MAP SETUP
   ============================ */
function initMap(){
  map = L.map("map", { zoomControl:false, worldCopyJump:true }).setView([centre.lat, centre.lon], 11);

  L.tileLayer("https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png", {
    maxZoom: 19, subdomains: "abcd"
  }).addTo(map);

  aircraftLayer = L.layerGroup().addTo(map);

  // Circles are vector overlays, so they remain bright regardless of tile dimming
  searchCircle = L.circle([centre.lat, centre.lon], {
    radius: cfg.searchKm * 1000,
    color: "#3b6cff",
    weight: 3,
    opacity: 0.9,
    fillOpacity: 0.05
  }).addTo(map);

  warnCircle = L.circle([centre.lat, centre.lon], {
    radius: cfg.warnKm * 1000,
    color: "#ff2b2b",
    weight: 3,
    opacity: 0.95,
    fillOpacity: 0.07
  }).addTo(map);

  updateUiTexts();
  applyTileMode();

  map.on("dblclick", (e) => {
    centre = { lat: e.latlng.lat, lon: e.latlng.lng };
    setCentre(centre, true);
    saveSettings();
  });

  setupRadarCanvas();
  requestAnimationFrame(radarLoop);
}

function setCentre(c, pan=false){
  searchCircle.setLatLng([c.lat, c.lon]);
  warnCircle.setLatLng([c.lat, c.lon]);
  searchCircle.setRadius(cfg.searchKm * 1000);
  warnCircle.setRadius(cfg.warnKm * 1000);

  if (pan) map.panTo([c.lat, c.lon], { animate:true, duration:0.6 });
  updateUiTexts();
}

function updateUiTexts(){
  $("centreText").textContent = `${centre.lat.toFixed(6)}, ${centre.lon.toFixed(6)}`;
  $("ceilingText").textContent = cfg.ceilingFt.toLocaleString();
  $("searchText").textContent = cfg.searchKm;
  $("warnText").textContent = cfg.warnKm;
  $("pollText").textContent = `${cfg.pollSec}s`;
  $("windowText").textContent = `${ACTIVE_WINDOW.start}–${ACTIVE_WINDOW.end}`;
}

function applyTileMode(){
  // "nightMode" just controls tile brightness. Markers/overlays unaffected.
  document.body.classList.remove("light-tiles", "no-tiles-dim");
  if (cfg.nightMode) {
    // keep default darker tiles
  } else {
    document.body.classList.add("light-tiles");
  }
}

/* ============================
   DATA NORMALISATION + FILTERS
   ============================ */
function altFt(ac){
  if (ac.alt_baro === "ground") return 0;
  if (isNumber(ac.alt_baro)) return ac.alt_baro;
  if (isNumber(ac.alt_geom)) return ac.alt_geom;
  return null;
}
function trackDeg(ac){
  if (isNumber(ac.track)) return ac.track;
  if (isNumber(ac.true_heading)) return ac.true_heading;
  return null;
}
function speedKt(ac){
  return isNumber(ac.gs) ? ac.gs : 0;
}

function shouldDisplay(ac){
  if (!isNumber(ac.lat) || !isNumber(ac.lon)) return false;

  if (isNumber(ac.seen_pos) && ac.seen_pos > cfg.staleSec) return false;

  // bin obvious noise
  if (ac.t === "TWR") return false;

  const a = altFt(ac);
  if (a === null) return false;

  const gs = speedKt(ac);
  if (a === 0 && gs < 5) return false;

  if (a > cfg.ceilingFt) return false;

  const dKm = map.distance([centre.lat, centre.lon], [ac.lat, ac.lon]) / 1000;
  if (dKm > cfg.searchKm) return false;

  return true;
}

/* ============================
   APPROACH LOGIC
   ============================ */
function degToRad(d){ return d * Math.PI / 180; }
function radToDeg(r){ return r * 180 / Math.PI; }

function projectLatLon(lat, lon, bearingDeg, distanceKm){
  const R = 6371;
  const br = degToRad(bearingDeg);
  const lat1 = degToRad(lat);
  const lon1 = degToRad(lon);
  const d = distanceKm / R;

  const lat2 = Math.asin(Math.sin(lat1)*Math.cos(d) + Math.cos(lat1)*Math.sin(d)*Math.cos(br));
  const lon2 = lon1 + Math.atan2(Math.sin(br)*Math.sin(d)*Math.cos(lat1), Math.cos(d) - Math.sin(lat1)*Math.sin(lat2));
  return { lat: radToDeg(lat2), lon: radToDeg(lon2) };
}

function isApproachingWarning(ac){
  const trk = trackDeg(ac);
  const gs = speedKt(ac);
  if (!isNumber(trk) || gs < 30) return false;

  const d0Km = map.distance([centre.lat, centre.lon], [ac.lat, ac.lon]) / 1000;
  if (d0Km <= cfg.warnKm) return false;

  const aheadKm = 20;
  const p1 = projectLatLon(ac.lat, ac.lon, trk, aheadKm);
  const d1Km = map.distance([centre.lat, centre.lon], [p1.lat, p1.lon]) / 1000;
  return d1Km <= cfg.warnKm;
}

function getCss(varName){
  return getComputedStyle(document.documentElement).getPropertyValue(varName).trim();
}
function colourFor(ac){
  const dKm = map.distance([centre.lat, centre.lon], [ac.lat, ac.lon]) / 1000;
  if (dKm <= cfg.warnKm) return getCss("--red");
  if (isApproachingWarning(ac)) return getCss("--yellow");
  return getCss("--green");
}

/* ============================
   MARKER HTML (DOT + LABEL BOX)
   ============================ */
function safeTxt(s){
  return String(s ?? "").replace(/[&<>"']/g, m => ({
    "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;"
  }[m]));
}

function buildMarkerHtml(ac, col){
  const flight = (ac.flight || "").trim();
  const reg = (ac.r || "").trim();
  const typ = (ac.t || "").trim();

  const a = altFt(ac);
  const altStr = (a === null) ? "n/a" : (a === 0 ? "GND" : `${Math.round(a)} ft`);

  const trk = trackDeg(ac);
  const hdgStr = isNumber(trk) ? `${Math.round(trk)}°` : "–";

  const gs = speedKt(ac);
  const gsStr = gs ? `${Math.round(gs)} kt` : "";

  const top = safeTxt(flight || reg || ac.hex);
  const sub = safeTxt(`${typ}  ${altStr}  ${hdgStr}  ${gsStr}`.trim());

  // If labels are off, just render the dot
  if (!cfg.labelsOn) {
    return `<div class="ac-marker" style="color:${col}"><div class="ac-dot"></div></div>`;
  }

  return `
    <div class="ac-marker" style="color:${col}">
      <div class="ac-dot"></div>
      <div class="ac-label">
        <div class="top">${top}</div>
        <div class="sub">${sub}</div>
      </div>
    </div>
  `.trim();
}

function makeDivIcon(ac, col){
  return L.divIcon({
    className: "",           // we fully style our own HTML
    html: buildMarkerHtml(ac, col),
    iconSize: [1, 1],        // size handled by CSS
    iconAnchor: [0, 0],
  });
}

/* ============================
   RENDERING
   ============================ */
function updateAircraft(acList){
  const visibleHex = new Set();

  for (const ac of acList) {
    if (!shouldDisplay(ac)) continue;

    const hex = ac.hex;
    visibleHex.add(hex);

    const col = colourFor(ac);
    const latlng = L.latLng(ac.lat, ac.lon);

    let entry = markerByHex.get(hex);
    if (!entry) {
      const marker = L.marker(latlng, { icon: makeDivIcon(ac, col), interactive: false }).addTo(aircraftLayer);
      entry = { marker, vectorLine: null, trailLine: null, trailPts: [] };
      markerByHex.set(hex, entry);
    } else {
      entry.marker.setLatLng(latlng);
      entry.marker.setIcon(makeDivIcon(ac, col));
    }

    // Heading vector
    if (cfg.showVectors) {
      const trk = trackDeg(ac);
      const gs = speedKt(ac);
      if (isNumber(trk) && gs >= 20) {
        const aheadKm = 12;
        const p1 = projectLatLon(ac.lat, ac.lon, trk, aheadKm);
        const lineLatLngs = [latlng, L.latLng(p1.lat, p1.lon)];
        if (!entry.vectorLine) {
          entry.vectorLine = L.polyline(lineLatLngs, {
            color: col,
            weight: 3,
            opacity: 0.85,
            dashArray: "6 8"
          }).addTo(aircraftLayer);
        } else {
          entry.vectorLine.setLatLngs(lineLatLngs);
          entry.vectorLine.setStyle({ color: col, opacity: 0.85, weight: 3 });
        }
      } else if (entry.vectorLine) {
        aircraftLayer.removeLayer(entry.vectorLine);
        entry.vectorLine = null;
      }
    } else if (entry.vectorLine) {
      aircraftLayer.removeLayer(entry.vectorLine);
      entry.vectorLine = null;
    }

    // Trails
    if (cfg.trails) {
      const tNow = Date.now();
      entry.trailPts.push({ latlng, t: tNow });

      const keepMs = 120000;
      entry.trailPts = entry.trailPts.filter(p => (tNow - p.t) <= keepMs);

      const latlngs = entry.trailPts.map(p => p.latlng);

      if (!entry.trailLine) {
        entry.trailLine = L.polyline(latlngs, {
          color: col,
          weight: 3,
          opacity: 0.40
        }).addTo(aircraftLayer);
      } else {
        entry.trailLine.setLatLngs(latlngs);
        entry.trailLine.setStyle({ color: col, opacity: 0.40, weight: 3 });
      }
    } else {
      if (entry.trailLine) {
        aircraftLayer.removeLayer(entry.trailLine);
        entry.trailLine = null;
      }
      entry.trailPts = [];
    }
  }

  // Remove markers not seen this tick
  for (const [hex, entry] of markerByHex.entries()) {
    if (!visibleHex.has(hex)) {
      aircraftLayer.removeLayer(entry.marker);
      if (entry.vectorLine) aircraftLayer.removeLayer(entry.vectorLine);
      if (entry.trailLine) aircraftLayer.removeLayer(entry.trailLine);
      markerByHex.delete(hex);
    }
  }

  $("visiblePill").textContent = `Visible: ${markerByHex.size}`;
}

/* ============================
   FETCHING
   ============================ */
async function fetchAircraft(){
  if (!isWithinWindow()) {
    $("statusText").textContent = "Paused (outside hours)";
    return;
  }

  const rNm = clamp(Math.ceil(kmToNm(cfg.searchKm)), 1, 250);
  const url = `${WORKER_BASE}/point?lat=${encodeURIComponent(centre.lat)}&lon=${encodeURIComponent(centre.lon)}&radiusNm=${encodeURIComponent(rNm)}`;

  $("statusText").textContent = "Fetching…";

  try {
    const resp = await fetch(url, { cache: "no-store" });
    if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
    const data = await resp.json();

    const list = Array.isArray(data.ac) ? data.ac : [];
    updateAircraft(list);

    $("lastUpdate").textContent = nowIsoTime();
    $("statusText").textContent = `OK (${list.length} raw)`;
  } catch (e) {
    console.error(e);
    $("statusText").textContent = "Error";
  }
}

/* ============================
   POLLING + HARD RELOAD
   ============================ */
function startPolling(){
  stopPolling();
  fetchAircraft();

  pollingTimer = setInterval(fetchAircraft, cfg.pollSec * 1000);

  hardReloadTimer = setInterval(() => {
    if (isWithinWindow()) location.reload();
  }, HARD_RELOAD_MINUTES * 60 * 1000);
}

function stopPolling(){
  if (pollingTimer) clearInterval(pollingTimer);
  if (hardReloadTimer) clearInterval(hardReloadTimer);
  pollingTimer = null;
  hardReloadTimer = null;
}

/* ============================
   RADAR SWEEP (ABOVE EVERYTHING)
   ============================ */
let radarCtx;
let sweepAngle = 0;

function setupRadarCanvas(){
  const c = $("radarCanvas");
  radarCtx = c.getContext("2d");

  function resize(){
    c.width = Math.floor(window.innerWidth * devicePixelRatio);
    c.height = Math.floor(window.innerHeight * devicePixelRatio);
    c.style.width = window.innerWidth + "px";
    c.style.height = window.innerHeight + "px";
    radarCtx.setTransform(devicePixelRatio, 0, 0, devicePixelRatio, 0, 0);
  }
  window.addEventListener("resize", resize);
  resize();
}

function radarLoop(){
  requestAnimationFrame(radarLoop);

  if (!cfg.radarSweep) {
    radarCtx.clearRect(0,0,window.innerWidth, window.innerHeight);
    return;
  }

  // soft persistence
  radarCtx.fillStyle = "rgba(0,0,0,0.10)";
  radarCtx.fillRect(0,0,window.innerWidth, window.innerHeight);

  const centrePx = map.latLngToContainerPoint([centre.lat, centre.lon]);
  const maxR = Math.min(window.innerWidth, window.innerHeight) * 0.55;

  // rings
  radarCtx.save();
  radarCtx.strokeStyle = "rgba(255,255,255,0.10)";
  radarCtx.lineWidth = 1;
  for (let i=1;i<=6;i++){
    radarCtx.beginPath();
    radarCtx.arc(centrePx.x, centrePx.y, (maxR*i)/6, 0, Math.PI*2);
    radarCtx.stroke();
  }

  // crosshair
  radarCtx.strokeStyle = "rgba(255,255,255,0.12)";
  radarCtx.beginPath(); radarCtx.moveTo(centrePx.x-maxR, centrePx.y); radarCtx.lineTo(centrePx.x+maxR, centrePx.y); radarCtx.stroke();
  radarCtx.beginPath(); radarCtx.moveTo(centrePx.x, centrePx.y-maxR); radarCtx.lineTo(centrePx.x, centrePx.y+maxR); radarCtx.stroke();

  // sweep
  const speed = isWithinWindow() ? (Math.PI*2) / (cfg.sweepSec * 60) : (Math.PI*2) / (12*60);
  sweepAngle += speed;
  if (sweepAngle > Math.PI*2) sweepAngle -= Math.PI*2;

  const wedge = Math.PI / 10;
  const start = sweepAngle - wedge/2;
  const end = sweepAngle + wedge/2;

  const grad = radarCtx.createRadialGradient(centrePx.x, centrePx.y, 0, centrePx.x, centrePx.y, maxR);
  grad.addColorStop(0, "rgba(57,255,20,0.00)");
  grad.addColorStop(0.22, "rgba(57,255,20,0.10)");
  grad.addColorStop(1, "rgba(57,255,20,0.00)");

  radarCtx.fillStyle = grad;
  radarCtx.beginPath();
  radarCtx.moveTo(centrePx.x, centrePx.y);
  radarCtx.arc(centrePx.x, centrePx.y, maxR, start, end);
  radarCtx.closePath();
  radarCtx.fill();

  radarCtx.restore();
}

/* ============================
   SETTINGS
   ============================ */
function loadSettings(){
  try {
    const raw = localStorage.getItem("airPictureCfgV2");
    if (!raw) return;
    const s = JSON.parse(raw);
    for (const k of Object.keys(cfg)) if (k in s) cfg[k] = s[k];
    if (s.centre && isNumber(s.centre.lat) && isNumber(s.centre.lon)) centre = { ...s.centre };
  } catch {}
}

function saveSettings(){
  try { localStorage.setItem("airPictureCfgV2", JSON.stringify({ ...cfg, centre })); } catch {}
}

function readUiIntoCfg(){
  cfg.ceilingFt = clamp(Number($("ceilingFt").value || 1000), 50, 50000);
  cfg.searchKm  = clamp(Number($("searchKm").value || 10), 1, 250);
  cfg.warnKm    = clamp(Number($("warnKm").value || 5), 1, 250);
  cfg.staleSec  = clamp(Number($("staleSec").value || 30), 1, 120);
  cfg.pollSec   = clamp(Number($("pollSec").value || 10), 2, 60);
  cfg.sweepSec  = clamp(Number($("sweepSec").value || 6), 2, 20);

  cfg.useMyLocation = $("useMyLocation").checked;
  cfg.nightMode = $("nightMode").checked;
  cfg.radarSweep = $("radarSweep").checked;
  cfg.showVectors = $("showVectors").checked;
  cfg.trails = $("trails").checked;
  cfg.labelsOn = $("labelsOn").checked;
}

function writeCfgToUi(){
  $("ceilingFt").value = cfg.ceilingFt;
  $("searchKm").value = cfg.searchKm;
  $("warnKm").value = cfg.warnKm;
  $("staleSec").value = cfg.staleSec;
  $("pollSec").value = cfg.pollSec;
  $("sweepSec").value = cfg.sweepSec;

  $("useMyLocation").checked = cfg.useMyLocation;
  $("nightMode").checked = cfg.nightMode;
  $("radarSweep").checked = cfg.radarSweep;
  $("showVectors").checked = cfg.showVectors;
  $("trails").checked = cfg.trails;
  $("labelsOn").checked = cfg.labelsOn;

  updateUiTexts();
  applyTileMode();
}

async function maybeSetMyLocation(){
  if (!cfg.useMyLocation) return;
  if (!navigator.geolocation) return;

  return new Promise((resolve) => {
    navigator.geolocation.getCurrentPosition(
      (pos) => {
        centre = { lat: pos.coords.latitude, lon: pos.coords.longitude };
        setCentre(centre, true);
        resolve(true);
      },
      () => resolve(false),
      { enableHighAccuracy: false, timeout: 5000, maximumAge: 60000 }
    );
  });
}

function wireUi(){
  $("applyBtn").addEventListener("click", async () => {
    readUiIntoCfg();
    await maybeSetMyLocation();

    setCentre(centre, false);

    searchCircle.setRadius(cfg.searchKm * 1000);
    warnCircle.setRadius(cfg.warnKm * 1000);

    applyTileMode();
    saveSettings();

    aircraftLayer.clearLayers();
    markerByHex.clear();

    startPolling();
  });

  $("recenterBtn").addEventListener("click", () => {
    map.setView([centre.lat, centre.lon], map.getZoom(), { animate:true, duration:0.6 });
  });

  $("reloadBtn").addEventListener("click", () => location.reload());

  // keep status honest
  setInterval(() => {
    if (!isWithinWindow()) $("statusText").textContent = "Paused (outside hours)";
  }, 5000);
}

/* ============================
   BOOT
   ============================ */
(async function main(){
  loadSettings();
  initMap();
  wireUi();
  writeCfgToUi();

  await maybeSetMyLocation();
  map.setView([centre.lat, centre.lon], 11);
  setCentre(centre, false);

  startPolling();
})();
</script>
</body>
</html>
