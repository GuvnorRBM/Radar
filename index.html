<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Head Office Air Picture (for show)</title>

  <!-- Leaflet -->
  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
    integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
    crossorigin=""
  />
  <script
    src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
    integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
    crossorigin=""
  ></script>

  <style>
    :root{
      --bg: #050608;
      --panel: rgba(10,12,16,0.88);
      --panel2: rgba(10,12,16,0.74);
      --text: #e7eefc;
      --muted: rgba(231,238,252,0.70);
      --border: rgba(255,255,255,0.12);

      --green: #39ff14;   /* bright green */
      --red:   #ff2b2b;   /* bright red */
      --yellow:#ffe600;   /* bright yellow */
      --cyan:  #2dd8ff;
    }

    html, body {
      height: 100%;
      margin: 0;
      background: var(--bg);
      color: var(--text);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
      overflow: hidden;
    }

    #map {
      position: absolute;
      inset: 0;
      background: #000;
    }

    /* Extra dim overlay to make the map properly dark */
    .map-dimmer {
      pointer-events: none;
      position: absolute;
      inset: 0;
      background: rgba(0,0,0,0.45);
      mix-blend-mode: multiply;
      z-index: 600;
      opacity: 1;
      transition: opacity 180ms ease;
    }
    body.light-dimmer .map-dimmer { opacity: 0.18; }
    body.no-dimmer .map-dimmer { opacity: 0; }

    /* Radar sweep overlay */
    .radar-overlay {
      pointer-events: none;
      position: absolute;
      inset: 0;
      z-index: 650;
      opacity: 0.9;
    }

    /* Top title bar */
    .titlebar {
      position: absolute;
      left: 50%;
      top: 10px;
      transform: translateX(-50%);
      z-index: 900;
      padding: 10px 14px;
      background: rgba(10,12,16,0.82);
      border: 1px solid var(--border);
      border-radius: 10px;
      backdrop-filter: blur(8px);
      font-weight: 700;
      letter-spacing: 0.2px;
      box-shadow: 0 12px 28px rgba(0,0,0,0.35);
      white-space: nowrap;
    }

    /* Right control panel */
    .panel {
      position: absolute;
      right: 14px;
      top: 14px;
      z-index: 950;
      width: 360px;
      max-width: calc(100vw - 28px);
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 14px;
      padding: 12px;
      backdrop-filter: blur(10px);
      box-shadow: 0 18px 44px rgba(0,0,0,0.45);
    }

    .panel h2 {
      margin: 0 0 8px 0;
      font-size: 14px;
      font-weight: 800;
    }

    .kv {
      font-size: 12px;
      color: var(--muted);
      line-height: 1.5;
    }

    .grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
      margin-top: 10px;
    }

    .field {
      background: var(--panel2);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 10px;
    }

    .field label {
      display: block;
      font-size: 12px;
      color: var(--muted);
      margin-bottom: 6px;
    }

    .field input[type="number"],
    .field input[type="text"]{
      width: 100%;
      box-sizing: border-box;
      padding: 8px 10px;
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,0.14);
      background: rgba(0,0,0,0.35);
      color: var(--text);
      outline: none;
      font-size: 13px;
    }

    .row {
      display: flex;
      gap: 10px;
      align-items: center;
      margin-top: 10px;
      flex-wrap: wrap;
    }

    .btn {
      cursor: pointer;
      user-select: none;
      padding: 9px 10px;
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,0.14);
      background: rgba(255,255,255,0.06);
      color: var(--text);
      font-weight: 700;
      font-size: 12px;
    }
    .btn:hover { background: rgba(255,255,255,0.10); }

    .toggle {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 9px 10px;
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,0.14);
      background: rgba(255,255,255,0.06);
      font-size: 12px;
      font-weight: 700;
    }
    .toggle input { transform: translateY(1px); }

    .status {
      margin-top: 10px;
      font-size: 12px;
      color: var(--muted);
      display: flex;
      justify-content: space-between;
      gap: 10px;
    }

    .pill {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 6px 10px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.14);
      background: rgba(0,0,0,0.35);
      font-size: 12px;
      font-weight: 800;
      color: var(--text);
    }

    .legend {
      margin-top: 10px;
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 8px;
      font-size: 12px;
      color: var(--muted);
    }
    .dot {
      width: 10px;
      height: 10px;
      border-radius: 999px;
      display: inline-block;
      margin-right: 8px;
      vertical-align: middle;
      box-shadow: 0 0 12px rgba(0,0,0,0.4);
    }

    /* Leaflet tweaks */
    .leaflet-control-attribution { display:none; }
    .leaflet-container { background: #000; }
  </style>
</head>

<body>
  <div id="map"></div>
  <div class="map-dimmer"></div>
  <canvas class="radar-overlay" id="radarCanvas"></canvas>

  <div class="titlebar" id="titlebar">Head Office Air Picture (for show)</div>

  <div class="panel">
    <h2>Controls</h2>
    <div class="kv" id="kvInfo">
      Centre: <span id="centreText"></span><br/>
      Filters: under <span id="ceilingText"></span> ft, within <span id="searchText"></span> km, warn within <span id="warnText"></span> km<br/>
      Polling: <span id="pollText"></span> (auto-pauses outside <span id="windowText"></span>)
    </div>

    <div class="grid">
      <div class="field">
        <label for="ceilingFt">Max altitude (ft)</label>
        <input id="ceilingFt" type="number" min="50" max="50000" step="50" value="1000" />
      </div>
      <div class="field">
        <label for="searchKm">Search radius (km)</label>
        <input id="searchKm" type="number" min="1" max="250" step="1" value="10" />
      </div>
      <div class="field">
        <label for="warnKm">Warning radius (km)</label>
        <input id="warnKm" type="number" min="1" max="250" step="1" value="5" />
      </div>
      <div class="field">
        <label for="staleSec">Max stale (sec)</label>
        <input id="staleSec" type="number" min="1" max="120" step="1" value="30" />
      </div>
      <div class="field">
        <label for="pollSec">Poll interval (sec)</label>
        <input id="pollSec" type="number" min="2" max="60" step="1" value="10" />
      </div>
      <div class="field">
        <label for="sweepSec">Radar sweep (sec)</label>
        <input id="sweepSec" type="number" min="2" max="20" step="1" value="6" />
      </div>
    </div>

    <div class="row">
      <span class="toggle"><input type="checkbox" id="useMyLocation" /> Use my location</span>
      <span class="toggle"><input type="checkbox" id="nightMode" checked /> Night mode</span>
      <span class="toggle"><input type="checkbox" id="radarSweep" checked /> Radar sweep</span>
      <span class="toggle"><input type="checkbox" id="showVectors" checked /> Heading lines</span>
      <span class="toggle"><input type="checkbox" id="trails" checked /> Trails</span>
    </div>

    <div class="row">
      <button class="btn" id="applyBtn">Apply</button>
      <button class="btn" id="recenterBtn">Re-centre</button>
      <button class="btn" id="reloadBtn">Hard reload</button>
      <span class="pill" id="visiblePill">Visible: 0</span>
    </div>

    <div class="status">
      <div>Last update: <span id="lastUpdate">–</span></div>
      <div>Status: <span id="statusText">Idle</span></div>
    </div>

    <div class="legend">
      <div><span class="dot" style="background: var(--green)"></span>Outside warning</div>
      <div><span class="dot" style="background: var(--yellow)"></span>Likely to enter warning</div>
      <div><span class="dot" style="background: var(--red)"></span>Inside warning</div>
      <div><span class="dot" style="background: #9aa8c7"></span>Filtered out</div>
    </div>

    <div class="kv" style="margin-top:10px;">
      Data via your Cloudflare Worker proxy.<br/>
      Tip: for the office wall, leave polling on, and it will auto-pause outside 08:30–17:30 and hard reload every 30 minutes while active.
    </div>
  </div>

<script>
/* ============================
   CONFIG YOU WILL EDIT
   ============================ */
const WORKER_BASE = "https://raspy-breeze-3e34.j-wilkinson.workers.dev";

// Head Office default centre (your coords)
const HQ = { lat: 53.10643205468523, lon: -1.3190169903418059 };

// Active time window (local browser time)
const ACTIVE_WINDOW = { start: "08:30", end: "17:30" };

// Hard reload cadence while active (minutes)
const HARD_RELOAD_MINUTES = 30;

/* ============================
   INTERNAL STATE
   ============================ */
let centre = { ...HQ };
let map, aircraftLayer;
let searchCircle, warnCircle;

let pollingTimer = null;
let hardReloadTimer = null;

const markerByHex = new Map();      // hex -> { marker, label, vectorLine, trailLine, trailPts: [{latlng, t}] }
let lastFetchMs = 0;

let cfg = {
  ceilingFt: 1000,
  searchKm: 10,
  warnKm: 5,
  staleSec: 30,
  pollSec: 10,
  sweepSec: 6,
  useMyLocation: false,
  nightMode: true,
  radarSweep: true,
  showVectors: true,
  trails: true,
};

function $(id){ return document.getElementById(id); }
function clamp(n, a, b){ return Math.min(b, Math.max(a, n)); }
function nowIsoTime(){
  const d = new Date();
  return d.toLocaleTimeString([], { hour: "2-digit", minute: "2-digit", second: "2-digit" });
}
function kmToNm(km){ return km / 1.852; }
function pad2(n){ return String(n).padStart(2, "0"); }

function parseHM(hm){
  const [h,m] = hm.split(":").map(x=>parseInt(x,10));
  return { h, m };
}
function isWithinWindow(d = new Date()){
  const s = parseHM(ACTIVE_WINDOW.start);
  const e = parseHM(ACTIVE_WINDOW.end);
  const mins = d.getHours() * 60 + d.getMinutes();
  const sMins = s.h * 60 + s.m;
  const eMins = e.h * 60 + e.m;
  return mins >= sMins && mins <= eMins;
}

/* ============================
   MAP SETUP
   ============================ */
function initMap(){
  map = L.map("map", {
    zoomControl: false,
    worldCopyJump: true
  }).setView([centre.lat, centre.lon], 11);

  // Dark tile (still readable)
  const tiles = L.tileLayer(
    "https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png",
    { maxZoom: 19, subdomains: "abcd" }
  );
  tiles.addTo(map);

  aircraftLayer = L.layerGroup().addTo(map);

  // Rings
  searchCircle = L.circle([centre.lat, centre.lon], {
    radius: cfg.searchKm * 1000,
    color: "#3b6cff",
    weight: 2,
    opacity: 0.55,
    fillOpacity: 0.08
  }).addTo(map);

  warnCircle = L.circle([centre.lat, centre.lon], {
    radius: cfg.warnKm * 1000,
    color: "#ff2b2b",
    weight: 2,
    opacity: 0.75,
    fillOpacity: 0.10
  }).addTo(map);

  updateUiTexts();
  applyNightMode();

  map.on("dblclick", (e) => {
    centre = { lat: e.latlng.lat, lon: e.latlng.lng };
    setCentre(centre, true);
    saveSettings();
  });

  setupRadarCanvas();
  requestAnimationFrame(radarLoop);
}

function setCentre(c, pan = false){
  // Update circles
  searchCircle.setLatLng([c.lat, c.lon]);
  warnCircle.setLatLng([c.lat, c.lon]);
  searchCircle.setRadius(cfg.searchKm * 1000);
  warnCircle.setRadius(cfg.warnKm * 1000);

  if (pan) map.panTo([c.lat, c.lon], { animate: true, duration: 0.6 });
  updateUiTexts();
}

function updateUiTexts(){
  $("centreText").textContent = `${centre.lat.toFixed(6)}, ${centre.lon.toFixed(6)}`;
  $("ceilingText").textContent = cfg.ceilingFt.toLocaleString();
  $("searchText").textContent = cfg.searchKm;
  $("warnText").textContent = cfg.warnKm;
  $("pollText").textContent = `${cfg.pollSec}s`;
  $("windowText").textContent = `${ACTIVE_WINDOW.start}–${ACTIVE_WINDOW.end}`;
}

/* ============================
   DATA NORMALISATION + FILTERS
   ============================ */
function isNumber(x){ return typeof x === "number" && Number.isFinite(x); }

function altFt(ac){
  if (ac.alt_baro === "ground") return 0;
  if (isNumber(ac.alt_baro)) return ac.alt_baro;
  if (isNumber(ac.alt_geom)) return ac.alt_geom; // fallback
  return null;
}

function trackDeg(ac){
  if (isNumber(ac.track)) return ac.track;
  if (isNumber(ac.true_heading)) return ac.true_heading;
  return null;
}

function speedKt(ac){
  return isNumber(ac.gs) ? ac.gs : 0;
}

function shouldDisplay(ac){
  if (!isNumber(ac.lat) || !isNumber(ac.lon)) return false;

  if (isNumber(ac.seen_pos) && ac.seen_pos > cfg.staleSec) return false;

  // bin obvious non-aircraft noise
  if (ac.t === "TWR") return false;

  const a = altFt(ac);
  if (a === null) return false;

  // stationary ground clutter
  const gs = speedKt(ac);
  if (a === 0 && gs < 5) return false;

  // ceiling filter
  if (a > cfg.ceilingFt) return false;

  // within search radius (km)
  const dKm = map.distance([centre.lat, centre.lon], [ac.lat, ac.lon]) / 1000;
  if (dKm > cfg.searchKm) return false;

  return true;
}

/* ============================
   APPROACH LOGIC (THEATRE MODE)
   ============================ */
function degToRad(d){ return d * Math.PI / 180; }
function radToDeg(r){ return r * 180 / Math.PI; }

function projectLatLon(lat, lon, bearingDeg, distanceKm){
  const R = 6371;
  const br = degToRad(bearingDeg);
  const lat1 = degToRad(lat);
  const lon1 = degToRad(lon);
  const d = distanceKm / R;

  const lat2 = Math.asin(Math.sin(lat1)*Math.cos(d) + Math.cos(lat1)*Math.sin(d)*Math.cos(br));
  const lon2 = lon1 + Math.atan2(Math.sin(br)*Math.sin(d)*Math.cos(lat1), Math.cos(d) - Math.sin(lat1)*Math.sin(lat2));

  return { lat: radToDeg(lat2), lon: radToDeg(lon2) };
}

function isApproachingWarning(ac){
  // "Approaching" = currently outside warning, projected point within warning
  const trk = trackDeg(ac);
  const gs = speedKt(ac);

  if (!isNumber(trk) || gs < 30) return false; // ignore slow movers

  const d0Km = map.distance([centre.lat, centre.lon], [ac.lat, ac.lon]) / 1000;
  if (d0Km <= cfg.warnKm) return false;

  const aheadKm = 20; // theatre lookahead distance
  const p1 = projectLatLon(ac.lat, ac.lon, trk, aheadKm);
  const d1Km = map.distance([centre.lat, centre.lon], [p1.lat, p1.lon]) / 1000;

  return d1Km <= cfg.warnKm;
}

/* ============================
   RENDERING
   ============================ */
function colourFor(ac){
  const dKm = map.distance([centre.lat, centre.lon], [ac.lat, ac.lon]) / 1000;

  if (dKm <= cfg.warnKm) return getCss("--red"); // inside warning
  if (isApproachingWarning(ac)) return getCss("--yellow");
  return getCss("--green");
}

function getCss(varName){
  return getComputedStyle(document.documentElement).getPropertyValue(varName).trim();
}

function markerRadiusFor(ac){
  // a touch bigger for closer aircraft, and helicopters are often the fun stuff
  const dKm = map.distance([centre.lat, centre.lon], [ac.lat, ac.lon]) / 1000;
  let r = 5.5;
  if (dKm < 5) r = 7.0;
  if (dKm < 2) r = 8.0;
  if (String(ac.t || "").includes("H")) r += 0.8;
  return r;
}

function labelText(ac){
  const f = (ac.flight || "").trim();
  const reg = (ac.r || "").trim();
  const typ = (ac.t || "").trim();
  const a = altFt(ac);
  const aStr = (a === null) ? "n/a" : (a === 0 ? "GND" : `${Math.round(a)}ft`);
  const gs = speedKt(ac);
  const gsStr = gs ? `${Math.round(gs)}kt` : "";
  return `${f || reg || ac.hex}\n${typ}  ${aStr}  ${gsStr}`.trim();
}

function updateAircraft(acList){
  const visibleHex = new Set();

  for (const ac of acList) {
    if (!shouldDisplay(ac)) continue;

    const hex = ac.hex;
    visibleHex.add(hex);

    const col = colourFor(ac);
    const latlng = L.latLng(ac.lat, ac.lon);

    let entry = markerByHex.get(hex);
    if (!entry) {
      const marker = L.circleMarker(latlng, {
        radius: markerRadiusFor(ac),
        color: col,
        weight: 2,
        opacity: 0.95,
        fillColor: col,
        fillOpacity: 0.85
      }).addTo(aircraftLayer);

      marker.bindTooltip(labelText(ac), {
        permanent: false,
        direction: "top",
        opacity: 0.95
      });

      entry = {
        marker,
        vectorLine: null,
        trailLine: null,
        trailPts: []
      };
      markerByHex.set(hex, entry);
    } else {
      entry.marker.setLatLng(latlng);
      entry.marker.setStyle({
        radius: markerRadiusFor(ac),
        color: col,
        fillColor: col,
        fillOpacity: 0.85
      });
      entry.marker.setTooltipContent(labelText(ac));
    }

    // Heading vector
    if (cfg.showVectors) {
      const trk = trackDeg(ac);
      const gs = speedKt(ac);
      if (isNumber(trk) && gs >= 20) {
        const aheadKm = 12; // looks good at your scales
        const p1 = projectLatLon(ac.lat, ac.lon, trk, aheadKm);
        const lineLatLngs = [latlng, L.latLng(p1.lat, p1.lon)];
        if (!entry.vectorLine) {
          entry.vectorLine = L.polyline(lineLatLngs, {
            color: col,
            weight: 2,
            opacity: 0.70,
            dashArray: "6 8"
          }).addTo(aircraftLayer);
        } else {
          entry.vectorLine.setLatLngs(lineLatLngs);
          entry.vectorLine.setStyle({ color: col, opacity: 0.70 });
        }
      } else {
        if (entry.vectorLine) {
          aircraftLayer.removeLayer(entry.vectorLine);
          entry.vectorLine = null;
        }
      }
    } else {
      if (entry.vectorLine) {
        aircraftLayer.removeLayer(entry.vectorLine);
        entry.vectorLine = null;
      }
    }

    // Trails (fade by time)
    if (cfg.trails) {
      const tNow = Date.now();
      entry.trailPts.push({ latlng, t: tNow });

      // keep last 2 minutes
      const keepMs = 120000;
      entry.trailPts = entry.trailPts.filter(p => (tNow - p.t) <= keepMs);

      const latlngs = entry.trailPts.map(p => p.latlng);

      if (!entry.trailLine) {
        entry.trailLine = L.polyline(latlngs, {
          color: col,
          weight: 2,
          opacity: 0.35
        }).addTo(aircraftLayer);
      } else {
        entry.trailLine.setLatLngs(latlngs);
        entry.trailLine.setStyle({ color: col, opacity: 0.35 });
      }
    } else {
      if (entry.trailLine) {
        aircraftLayer.removeLayer(entry.trailLine);
        entry.trailLine = null;
      }
      entry.trailPts = [];
    }
  }

  // Remove markers not seen this tick
  for (const [hex, entry] of markerByHex.entries()) {
    if (!visibleHex.has(hex)) {
      aircraftLayer.removeLayer(entry.marker);
      if (entry.vectorLine) aircraftLayer.removeLayer(entry.vectorLine);
      if (entry.trailLine) aircraftLayer.removeLayer(entry.trailLine);
      markerByHex.delete(hex);
    }
  }

  $("visiblePill").textContent = `Visible: ${markerByHex.size}`;
}

/* ============================
   FETCHING
   ============================ */
async function fetchAircraft(){
  const active = isWithinWindow();
  if (!active) {
    $("statusText").textContent = "Paused (outside hours)";
    return;
  }

  const rNm = clamp(Math.ceil(kmToNm(cfg.searchKm)), 1, 250);
  const url = `${WORKER_BASE}/point?lat=${encodeURIComponent(centre.lat)}&lon=${encodeURIComponent(centre.lon)}&radiusNm=${encodeURIComponent(rNm)}`;

  $("statusText").textContent = "Fetching…";

  try {
    const resp = await fetch(url, { cache: "no-store" });
    if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
    const data = await resp.json();

    const list = Array.isArray(data.ac) ? data.ac : [];
    updateAircraft(list);

    lastFetchMs = Date.now();
    $("lastUpdate").textContent = nowIsoTime();
    $("statusText").textContent = `OK (${list.length} raw)`;
  } catch (e) {
    $("statusText").textContent = "Error";
    console.error(e);
  }
}

/* ============================
   POLLING + HARD RELOAD
   ============================ */
function startPolling(){
  stopPolling();

  // First tick immediately (if within hours)
  fetchAircraft();

  pollingTimer = setInterval(() => {
    fetchAircraft();
  }, cfg.pollSec * 1000);

  // Hard reload every 30 mins while active (to mimic DroneDesk’s timeout handling)
  hardReloadTimer = setInterval(() => {
    if (isWithinWindow()) location.reload();
  }, HARD_RELOAD_MINUTES * 60 * 1000);
}

function stopPolling(){
  if (pollingTimer) clearInterval(pollingTimer);
  if (hardReloadTimer) clearInterval(hardReloadTimer);
  pollingTimer = null;
  hardReloadTimer = null;
}

/* ============================
   RADAR SWEEP (THEATRE)
   ============================ */
let radarCtx, radarW = 0, radarH = 0;
let sweepAngle = 0;

function setupRadarCanvas(){
  const c = $("radarCanvas");
  radarCtx = c.getContext("2d");

  function resize(){
    radarW = c.width = window.innerWidth * devicePixelRatio;
    radarH = c.height = window.innerHeight * devicePixelRatio;
    c.style.width = window.innerWidth + "px";
    c.style.height = window.innerHeight + "px";
    radarCtx.setTransform(devicePixelRatio, 0, 0, devicePixelRatio, 0, 0);
  }
  window.addEventListener("resize", resize);
  resize();
}

function radarLoop(){
  requestAnimationFrame(radarLoop);

  if (!cfg.radarSweep) {
    radarCtx.clearRect(0,0,window.innerWidth, window.innerHeight);
    return;
  }

  // Only animate sweep when active hours, otherwise keep it calm
  const active = isWithinWindow();
  const speed = active ? (Math.PI * 2) / (cfg.sweepSec * 60) : (Math.PI * 2) / (12 * 60); // radians per frame-ish

  // Fade previous frame for ghosting
  radarCtx.fillStyle = "rgba(0,0,0,0.12)";
  radarCtx.fillRect(0,0,window.innerWidth, window.innerHeight);

  // Centre in screen space is map centre in pixels
  const centreLatLng = L.latLng(centre.lat, centre.lon);
  const centrePx = map.latLngToContainerPoint(centreLatLng);

  // Concentric rings for effect
  radarCtx.save();
  radarCtx.strokeStyle = "rgba(255,255,255,0.10)";
  radarCtx.lineWidth = 1;

  const maxR = Math.min(window.innerWidth, window.innerHeight) * 0.55;
  for (let i=1;i<=6;i++){
    radarCtx.beginPath();
    radarCtx.arc(centrePx.x, centrePx.y, (maxR*i)/6, 0, Math.PI*2);
    radarCtx.stroke();
  }

  // Crosshairs
  radarCtx.strokeStyle = "rgba(255,255,255,0.12)";
  radarCtx.beginPath();
  radarCtx.moveTo(centrePx.x - maxR, centrePx.y);
  radarCtx.lineTo(centrePx.x + maxR, centrePx.y);
  radarCtx.stroke();
  radarCtx.beginPath();
  radarCtx.moveTo(centrePx.x, centrePx.y - maxR);
  radarCtx.lineTo(centrePx.x, centrePx.y + maxR);
  radarCtx.stroke();

  // Sweep wedge
  sweepAngle += speed;
  if (sweepAngle > Math.PI * 2) sweepAngle -= Math.PI * 2;

  const wedge = Math.PI / 10; // wedge width
  const start = sweepAngle - wedge/2;
  const end = sweepAngle + wedge/2;

  // Green-ish sweep
  const grad = radarCtx.createRadialGradient(centrePx.x, centrePx.y, 0, centrePx.x, centrePx.y, maxR);
  grad.addColorStop(0, "rgba(57,255,20,0.00)");
  grad.addColorStop(0.25, "rgba(57,255,20,0.08)");
  grad.addColorStop(1, "rgba(57,255,20,0.00)");

  radarCtx.fillStyle = grad;
  radarCtx.beginPath();
  radarCtx.moveTo(centrePx.x, centrePx.y);
  radarCtx.arc(centrePx.x, centrePx.y, maxR, start, end);
  radarCtx.closePath();
  radarCtx.fill();

  radarCtx.restore();
}

/* ============================
   UI + SETTINGS
   ============================ */
function applyNightMode(){
  // This only controls the extra dimmer overlay intensity
  if (cfg.nightMode) {
    document.body.classList.remove("no-dimmer");
    document.body.classList.remove("light-dimmer");
  } else {
    document.body.classList.add("light-dimmer");
  }
}

function loadSettings(){
  try {
    const raw = localStorage.getItem("airPictureCfgV1");
    if (!raw) return;
    const s = JSON.parse(raw);

    // Merge known keys only
    for (const k of Object.keys(cfg)) {
      if (k in s) cfg[k] = s[k];
    }

    // Restore centre if saved
    if (s.centre && isNumber(s.centre.lat) && isNumber(s.centre.lon)) {
      centre = { lat: s.centre.lat, lon: s.centre.lon };
    }
  } catch {}
}

function saveSettings(){
  try {
    localStorage.setItem("airPictureCfgV1", JSON.stringify({
      ...cfg,
      centre
    }));
  } catch {}
}

function readUiIntoCfg(){
  cfg.ceilingFt = clamp(Number($("ceilingFt").value || 1000), 50, 50000);
  cfg.searchKm  = clamp(Number($("searchKm").value || 10), 1, 250);
  cfg.warnKm    = clamp(Number($("warnKm").value || 5), 1, 250);
  cfg.staleSec  = clamp(Number($("staleSec").value || 30), 1, 120);
  cfg.pollSec   = clamp(Number($("pollSec").value || 10), 2, 60);
  cfg.sweepSec  = clamp(Number($("sweepSec").value || 6), 2, 20);

  cfg.useMyLocation = $("useMyLocation").checked;
  cfg.nightMode = $("nightMode").checked;
  cfg.radarSweep = $("radarSweep").checked;
  cfg.showVectors = $("showVectors").checked;
  cfg.trails = $("trails").checked;
}

function writeCfgToUi(){
  $("ceilingFt").value = cfg.ceilingFt;
  $("searchKm").value = cfg.searchKm;
  $("warnKm").value = cfg.warnKm;
  $("staleSec").value = cfg.staleSec;
  $("pollSec").value = cfg.pollSec;
  $("sweepSec").value = cfg.sweepSec;

  $("useMyLocation").checked = cfg.useMyLocation;
  $("nightMode").checked = cfg.nightMode;
  $("radarSweep").checked = cfg.radarSweep;
  $("showVectors").checked = cfg.showVectors;
  $("trails").checked = cfg.trails;

  updateUiTexts();
  applyNightMode();
}

async function maybeSetMyLocation(){
  if (!cfg.useMyLocation) return;

  if (!navigator.geolocation) return;

  return new Promise((resolve) => {
    navigator.geolocation.getCurrentPosition(
      (pos) => {
        centre = { lat: pos.coords.latitude, lon: pos.coords.longitude };
        setCentre(centre, true);
        resolve(true);
      },
      () => resolve(false),
      { enableHighAccuracy: false, timeout: 5000, maximumAge: 60000 }
    );
  });
}

/* ============================
   BOOT
   ============================ */
function wireUi(){
  $("applyBtn").addEventListener("click", async () => {
    readUiIntoCfg();
    await maybeSetMyLocation();

    setCentre(centre, false);

    // update circles
    searchCircle.setRadius(cfg.searchKm * 1000);
    warnCircle.setRadius(cfg.warnKm * 1000);

    applyNightMode();
    saveSettings();

    // clear existing and restart
    aircraftLayer.clearLayers();
    markerByHex.clear();

    startPolling();
  });

  $("recenterBtn").addEventListener("click", () => {
    map.setView([centre.lat, centre.lon], map.getZoom(), { animate: true, duration: 0.6 });
  });

  $("reloadBtn").addEventListener("click", () => location.reload());

  // auto pause/resume without user intervention
  setInterval(() => {
    // keep status honest even if no fetch is happening
    if (!isWithinWindow()) {
      $("statusText").textContent = "Paused (outside hours)";
    }
  }, 5000);
}

(async function main(){
  loadSettings();
  initMap();
  wireUi();
  writeCfgToUi();

  // If user wants "use my location", do it at boot too
  await maybeSetMyLocation();
  map.setView([centre.lat, centre.lon], 11);
  setCentre(centre, false);

  startPolling();
})();
</script>
</body>
</html>
